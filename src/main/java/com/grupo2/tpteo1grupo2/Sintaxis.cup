package com.grupo2.tpteo1grupo2;
import java.util.ArrayList;
import java.util.List;
import java_cup.runtime.*;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.HashMap;
import java.io.*;
import java.nio.file.*;


parser code
{:

    public void syntax_error(Symbol s) {
        System.out.println("Error en la linea " + (s.right+1) + " columna " + (s.left+1) + ". "
            + s + " no reconocido, VALOR: " + s.value );
    }
   public void actualizarTipo(String nombre, String tipo) {
       // Nombre del archivo común para todos los nombres-tipos
       String archivo = "nombres_tipos.csv";

       try {
           // Realizar append al archivo con la nueva línea
           try (BufferedWriter writer = new BufferedWriter(new FileWriter(archivo, true))) {
               writer.write(nombre + "," + tipo + "\n");
           }

           System.out.println("Archivo actualizado: " + archivo);

       } catch (IOException e) {
           System.err.println("Error al actualizar el archivo CSV: " + e.getMessage());
       }
   }
   public void nuevoCsv(){
        String archivo = "nombres_tipos.csv";
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(archivo))) {
            writer.write("NOMBRE,TIPO\n"); // Sobrescribe y escribe la cabecera
        } catch (IOException e) {
                     System.err.println("Error al actualizar el archivo CSV: " + e.getMessage());
        }

   }
:}

action code
{:
public String reglas;

public String getReglas() {
    return reglas;
}

:}

/*Declaracion de Terminales */
terminal IF, THEN, ELSE, ENDIF, WHILE, ENDWHILE, ENDFOR, WRITE, FLOAT, INTEGER, STRING, OPLIST, ID, CONST_INT, CONST_REAL, CON_OR, CON_AND,
CONST_STRING, CONST_B, OP_MENOR, OP_MAYOR, OP_IGUAL, OP_MENOR_IGUAL, OP_MAYOR_IGUAL, OP_SUMA, OP_RESTA, OP_MULT, OP_DIV, ASIGN, DECLARACION, DECLARE_SECTION,
ENDDECLARE_SECTION, PROGRAM_SECTION, ENDPROGRAM_SECTION, ABRIR_PARENTESIS, CERRAR_PARENTESIS, ABRIR_LLAVE, CERRAR_LLAVE,
ABRIR_CORCHETE, CERRAR_CORCHETE, PUNTO_Y_COMA, ADMIRACION, INTERROGACION, COMA;

/*Declaracion de No Terminales*/
non terminal pgm, declare_sec, declaracion_n, program_sec, sentencia_n, program_write, sentencia_write, write_constante, declaracion,
    declaracion_aux, type, sentencia, asignacion, decision, iteracion, condicion, comparacion, comparador, conector, expresion, termino, factor, escritura,
    parametro_escritura, oplist, oplist_operaciones, oplist_const, const_numerica;

start with pgm;

pgm::= declare_sec program_sec {:reglas += "Regla 0: pgm ; Compilación completa\n";:}
    | program_write {:reglas += "Regla 1: pgm = PROGRAM WRITE; Compilación completa\n";:};

declare_sec::= DECLARE_SECTION:ds declaracion_n ENDDECLARE_SECTION:es {:reglas += "Regla 2: DECLARE_SEC = " + ds + " DECLARACIONES " + es + "\n";:};

declaracion_n::= declaracion_n declaracion {:reglas += "Regla 3: DECLARACIONES = DECLARACIONES DECLARACION\n";:}
    | declaracion {:reglas += "Regla 4: DECLARACIONES = DECLARACION\n";:};

program_sec::= PROGRAM_SECTION:ps sentencia_n ENDPROGRAM_SECTION:es {:reglas += "Regla 5: PROGRAM_SEC = " + ps + " SENTENCIAS " + es + "\n";:};

sentencia_n::= sentencia_n sentencia {:reglas += "Regla 6: SENTENCIAS = SENTENCIAS SENTENCIA\n";:}
    | sentencia {:reglas += "Regla 7: SENTENCIAS = SENTENCIA\n";:};

program_write::= PROGRAM_SECTION sentencia_write ENDPROGRAM_SECTION {:reglas += "Regla 8: PROGRAM WRITE = PROGRAM_SECTION SENTENCIA_WRITE ENDPROGRAM_SECTION\n";:};

sentencia_write::= sentencia_write write_constante {:reglas += "Regla 9: SENTENCIA WRITE = SENTENCIA_WRITE WRITE_CONSTANTE\n";:}
    | write_constante {:reglas += "Regla 10: SENTENCIA WRITE = WRITE_CONSTANTE\n";:};

write_constante::= WRITE:w CONST_STRING:c {:reglas += "Regla 11: WRITE CONSTANTE = " + w + c + "\n";:};

declaracion::= ABRIR_CORCHETE:ac ID:id declaracion_aux:da type:type CERRAR_CORCHETE:cc {:reglas += "Regla 12: DECLARATION = " + ac.toString() + id.toString() + da.toString() + type.toString() + cc.toString() + "\n";
    parser.actualizarTipo(id.toString(), type.toString());:};

declaracion_aux::= COMA:coma ID:id declaracion_aux:da type:t COMA {:reglas += "Regla 14: DECLARACION_AUX = " + id + coma + da + coma + t + "\n"; RESULT=id.toString()+coma.toString()+da.toString()+coma.toString()+t.toString();
    parser.actualizarTipo(id.toString(), t.toString());:}
    | CERRAR_CORCHETE:cc2 DECLARACION:d ABRIR_CORCHETE:aco {:reglas += "Regla 15: DECLARACION_AUX = " + cc2 + d + aco + "\n"; RESULT = cc2.toString() + d.toString() + aco.toString();
    parser.nuevoCsv();:};

type::= FLOAT:f {:reglas += "Regla 16: TYPE = " + f + "\n"; RESULT=f; :}
    | INTEGER:i {:reglas += "Regla 17: TYPE = " + i + "\n"; RESULT=i;:}
    | STRING:s {:reglas += "Regla 18: TYPE = " + s + "\n"; RESULT=s;:};

sentencia::= asignacion {:reglas += "Regla 19: SENTENCIA = ASIGNACION\n";:}
    | iteracion {:reglas += "Regla 20: SENTENCIA = ITERACION\n";:}
    | decision {:reglas += "Regla 21: SENTENCIA = DECISION\n";:}
    | escritura {:reglas += "Regla 22: SENTENCIA = ESCRITURA\n";:}
    | oplist {:reglas += "Regla 23: SENTENCIA = OPLIST\n";:};

asignacion::= ID:id ASIGN:a expresion {:reglas += "Regla 24: ASIGNACION = " + id + a + " EXPRESION \n";:}
    | ID:id ASIGN:a CONST_STRING:cs {:reglas += "Regla 25: ASIGNACION = " + id + a + cs + "\n";:};

decision::= IF:i ABRIR_PARENTESIS:ap condicion CERRAR_PARENTESIS:cp THEN:t sentencia_n ELSE:el sentencia_n ENDIF:endif {:reglas += "Regla 26: DECISION = " + i + ap + " CONDICION " + cp + t + " SENTENCIAS " + el + " SENTENCIAS " + endif + "\n";:}
    | IF:i1 ABRIR_PARENTESIS:ap1 condicion CERRAR_PARENTESIS:cp1 THEN:t1 sentencia_n ENDIF:endif1 {:reglas += "Regla 27: DECISION = " + i1 + ap1 + " CONDICION " + cp1 + t1 + " SENTENCIAS " + endif1 + "\n";:};

iteracion::= WHILE:w ABRIR_PARENTESIS:ap condicion CERRAR_PARENTESIS:cp THEN:t sentencia_n ENDWHILE:ew {:reglas += "Regla 28: ITERACION = " + w + ap + " CONDICION " + cp + t + " SENTENCIAS " + ew + "\n";:};

condicion::= comparacion {:reglas += "Regla 29: CONDICION = COMPARACION\n";:}
    | comparacion conector:c comparacion {:reglas += "Regla 30: CONDICION = COMPARACION " + c + " COMPARACION\n";:};

conector::= CON_AND {:reglas += "Regla 1234124: conector = CON_AND\n";:}
    | CON_OR {:reglas += "Regla 1234124: conector = CON_OR\n";:};

comparacion::= expresion comparador:c expresion {:reglas += "Regla 31: COMPARACION = EXPRESION " + c + " EXPRESION\n";:}
    | ABRIR_PARENTESIS:ap comparacion CERRAR_PARENTESIS:cp {:reglas += "Regla 32: COMPARACION = " + ap + " COMPARACION " + cp + "\n";:};

comparador::= OP_MAYOR:ma {:reglas += "Regla 33: COMPARADO = " + ma + "\n"; RESULT=ma; :}
    | OP_MENOR:me {:reglas += "Regla 34: COMPARADO = " + me + "\n"; RESULT=me; :}
    | OP_IGUAL:i {:reglas += "Regla 35: COMPARADO = " + i + "\n"; RESULT=i; :}
    | OP_MENOR_IGUAL:mei {:reglas += "Regla 36: COMPARADO = " + mei + "\n"; RESULT=mei; :}
    | OP_MAYOR_IGUAL:mai {:reglas += "Regla 37: COMPARADO = " + mai + "\n"; RESULT=mai; :};

expresion::= expresion OP_SUMA:os termino {:reglas += "Regla 38: EXPRESION = EXPRESION " + os + " TERMINO\n"; :}
    | expresion OP_RESTA:or termino {:reglas += "Regla 39: EXPRESION = EXPRESION " + or + " TERMINO\n";:}
    | termino:t {:reglas += "Regla 40: EXPRESION = TERMINO\n";:};

termino::= termino OP_MULT:om factor {:reglas += "Regla 41: TERMINO = TERMINO " + om + " FACTOR\n";:}
    | termino OP_DIV:od factor {:reglas += "Regla 42: TERMINO = TERMINO " + od + " FACTOR\n";:}
    | factor {:reglas += "Regla 43: TERMINO = FACTOR\n"; :};

factor::= ABRIR_PARENTESIS:a expresion:e CERRAR_PARENTESIS:c {:reglas += "Regla 44: FACTOR = " + a + "EXPRESION" + c + "\n";:}
    | ID:id {:reglas += "Regla 45: FACTOR = " + id + "\n";:}
    | const_numerica:cn {:reglas += "Regla 46: FACTOR = " + cn + "\n";:};

escritura::= WRITE:w parametro_escritura:param {:reglas += "Regla 47: ESCRITURA = " + w + param + "\n";:};

parametro_escritura::= ID:id {:reglas += "Regla 48: VARIABLE valor = " + id + "\n"; RESULT=id; :}
    | const_numerica:const_numerica {:reglas += "Regla 49: CONSTANTE NUMÉRICA valor = " + const_numerica + "\n"; RESULT=const_numerica; :}
    | CONST_STRING:const_string {:reglas += "Regla 50: CONSTANTE STRING valor = " + const_string + "\n"; RESULT=const_string; :};

oplist::= OPLIST ABRIR_CORCHETE oplist_operaciones ABRIR_CORCHETE ID PUNTO_Y_COMA ID CERRAR_CORCHETE ABRIR_CORCHETE oplist_const CERRAR_CORCHETE CERRAR_CORCHETE {:reglas += "Regla 51: oplist\n";:};

oplist_operaciones::= OP_SUMA {:reglas += "Regla 52: oplist_operaciones\n";:}
    | OP_MULT {:reglas += "Regla 53: oplist_operaciones\n";:};

oplist_const::= oplist_const PUNTO_Y_COMA const_numerica {:reglas += "Regla 54: oplist_const\n";:}
    | const_numerica {:reglas += "Regla 55: oplist_const\n";:};

const_numerica::= CONST_B:const_b {:reglas += "Regla 56: CONSTANTE BINARIA valor = " + const_b + "\n"; RESULT=const_b;:}
    | CONST_REAL:const_real {:reglas += "Regla 57: CONSTANTE REAL valor = " + const_real + "\n"; RESULT=const_real; :}
    | CONST_INT:const_int {:reglas += "Regla 58: CONSTANTE ENTERA valor = " + const_int + "\n"; RESULT=const_int; :};